<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Track your wrestling training journey">
  <meta name="theme-color" content="#ea580c">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Wrestling">
  
  <title>Wrestling Journey</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  
  <!-- Custom Stylesheet (UPGRADED) -->
  <link rel="stylesheet" href="style.css">

</head>
<body>
  <div id="root"></div>
  
  <script type="module" src="db.js"></script>
  <script src="auto-backup.js"></script>

  <script type="module">
    // Import all necessary functions from the new db.js module
    import {
      getPractices,
      addPractice as dbAddPractice,
      deletePractice as dbDeletePractice,
      updatePractice as dbUpdatePractice,
      getProfile,
      setProfile,
      clearAllData,
      ALL_BADGES,
      checkBadges as dbCheckBadges,
      PHASES,
      getPhase as dbGetPhase,
      calculatePracticeStats as dbCalculatePracticeStats,
      IDENTITY_LEVELS,
      getCurrentIdentityLevel,
      getIdentityProgress,
      MILESTONES,
      exportAllData,
      DEFAULT_BACKUP_SETTINGS,
      normalizeBackupSettings
    } from './db.js';
    
    document.addEventListener('DOMContentLoaded', () => {
      const root = document.getElementById('root');
      let practices = [];
      let profile = {};
      let currentTab = 'dashboard';
      let selectedPracticeId = null;
      let showPromptForPractice = false;
      let promptCopyState = 'idle';
      let promptCopyError = '';
      let storyDraft = '';
      let editingStory = false;
      let currentPromptText = '';
      let expandedPromptPracticeId = null;

      const BACKUP_SNAPSHOT_ENTRY_LIMIT = 120;
      const BACKUP_METADATA_VERSION = 2;
      let appVersion = '';
      let manifestVersionPromise = null;
      let serviceWorkerRegistration = null;
      let pendingUpdateWorker = null;
      let updateBannerTimeoutId = null;
      let hasReloadedForUpdate = false;
      let autoBackupInitialized = false;
      let hasScheduledInitialBackup = false;

      async function ensureAutoBackupInitialized(settings) {
        if (autoBackupInitialized || !isAutoBackupAvailable()) {
          return;
        }
        try {
          await AutoBackup.init({
            enabled: settings.enabled,
            getPayload: async ({ reason }) => {
              return await buildBackupPayload(reason || 'auto');
            },
            applySnapshot: async (payload) => {
              if (!payload || !payload.practices || !payload.profile) {
                throw new Error('Backup payload is missing required data.');
              }
              await clearAllData();
              if (Array.isArray(payload.practices)) {
                for (const practice of payload.practices) {
                  await dbAddPractice(practice);
                }
              }
              if (payload.profile) {
                await setProfile(payload.profile);
              }
            },
            onStatusChange: () => {
              requestAnimationFrame(() => render());
            }
          });
          autoBackupInitialized = true;
        } catch (error) {
          console.error('Failed to initialize automatic backups', error);
        }
      }

      // --- RENDER FUNCTION ---
      async function render() {
        practices = await getPractices();
        profile = await getProfile();
        profile = {
          ...profile,
          backupSettings: normalizeBackupSettings(profile.backupSettings)
        };

        await ensureAutoBackupInitialized(profile.backupSettings);

        if (!hasScheduledInitialBackup && isBackupEnabled()) {
          hasScheduledInitialBackup = true;
          scheduleAutoBackup('initial-load');
        }


        if (selectedPracticeId && !practices.some(p => p.id === selectedPracticeId)) {
          selectedPracticeId = null;
          showPromptForPractice = false;
          promptCopyState = 'idle';
          promptCopyError = '';
          storyDraft = '';
          editingStory = false;
          expandedPromptPracticeId = null;
        }

        const { current: currentPhase, next: nextPhase } = dbGetPhase(practices.length);

        // Update profile if a badge was earned
        const updatedProfile = dbCheckBadges(practices, profile);
        if (updatedProfile) {
            profile = updatedProfile;
            await setProfile(profile);
            scheduleAutoBackup('profile-updated');
        }

        const stats = {
          totalPractices: practices.length,
          avgIntensity: practices.length ? (practices.reduce((sum, p) => sum + (p.intensity || 0), 0) / practices.length).toFixed(1) : '0.0',
          totalTime: practices.reduce((sum, p) => sum + (p.duration || 0), 0),
          lastPracticeDate: practices.length ? new Date(practices.slice(-1)[0].date).toLocaleDateString() : 'N/A'
        };

        // Get comprehensive stats including streaks
        const fullStats = dbCalculatePracticeStats(practices);
        const identityLevel = getCurrentIdentityLevel(practices.length);

        const chronologicalPractices = practices.slice().sort((a, b) => {
          const dateA = new Date(a.date);
          const dateB = new Date(b.date);
          const validDateA = !isNaN(dateA.getTime());
          const validDateB = !isNaN(dateB.getTime());
          if (validDateA && validDateB) {
            return dateA - dateB;
          }
          if (validDateA) return -1;
          if (validDateB) return 1;
          return (a.id || 0) - (b.id || 0);
        });

        const selectedPractice = selectedPracticeId
          ? practices.find(p => p.id === selectedPracticeId)
          : null;
        const selectedPracticeIndex = selectedPractice
          ? chronologicalPractices.findIndex(p => p.id === selectedPractice.id)
          : -1;
        const selectedPracticeNumber = selectedPracticeIndex >= 0
          ? selectedPracticeIndex + 1
          : null;
        const promptPractice = selectedPractice
          ? {
              ...selectedPractice,
              practiceNumber: selectedPractice.practiceNumber ?? selectedPracticeNumber ?? practices.length
            }
          : null;
        const selectedPracticeHasStory = Boolean(
          selectedPractice && typeof selectedPractice.aiStory === 'string' && selectedPractice.aiStory.trim().length
        );
        const shouldShowPrompt = Boolean(selectedPractice && showPromptForPractice);
        const storyPromptText = shouldShowPrompt && promptPractice
          ? generateStoryPrompt(promptPractice, fullStats, identityLevel)
          : '';
        const trimmedPromptText = storyPromptText ? storyPromptText.trim() : '';
        const promptPreviewText = trimmedPromptText ? getPreviewText(trimmedPromptText) : '';
        const isPromptExpanded = Boolean(selectedPractice && expandedPromptPracticeId === selectedPractice.id);
        const isPromptTruncated = Boolean(trimmedPromptText && promptPreviewText && promptPreviewText !== trimmedPromptText);
        const promptDisplayText = (isPromptExpanded || !isPromptTruncated) ? trimmedPromptText : promptPreviewText;
        currentPromptText = trimmedPromptText;
        const storySavedDate = selectedPractice?.storyGeneratedDate
          ? new Date(selectedPractice.storyGeneratedDate).toLocaleString()
          : '';
        const storyDraftTrimmed = storyDraft.trim();
        const shouldShowStoryInput = Boolean(
          selectedPractice && (
            editingStory ||
            (showPromptForPractice && !selectedPracticeHasStory && (promptCopyState === 'success' || promptCopyState === 'manual'))
          )
        );
        const backupSectionMarkup = renderBackupSettingsSection();
        const versionMarkup = renderAppVersionMarkup();
        const practiceDetailMarkup = selectedPractice
          ? `
            <div class="practice-detail">
              <div class="practice-detail-header">
                <div>
                  <p class="eyebrow">${selectedPracticeNumber ? `Practice #${selectedPracticeNumber}` : 'Practice'}</p>
                  <h3 class="practice-detail-title">${new Date(selectedPractice.date).toLocaleDateString()} Â· ${selectedPractice.type}</h3>
                  <p class="practice-detail-notes">${escapeHTML(selectedPractice.notes)}</p>
                </div>
                <button id="close-practice-detail" class="button ghost small">Close</button>
              </div>
              <div class="practice-detail-metrics">
                ${selectedPractice.duration ? `<span>${selectedPractice.duration} min</span>` : ''}
                ${typeof selectedPractice.intensity === 'number' ? `<span>Intensity ${selectedPractice.intensity}/10</span>` : ''}
                ${typeof selectedPractice.physical === 'number' ? `<span>Physical ${selectedPractice.physical}/10</span>` : ''}
                ${typeof selectedPractice.mental === 'number' ? `<span>Mental ${selectedPractice.mental}/10</span>` : ''}
              </div>
              ${selectedPracticeHasStory ? `
                <section class="story-card">
                  <div class="story-card-header">
                    <h3 class="story-card-title">Saved Story</h3>
                    ${storySavedDate ? `<span class="story-card-date">Saved ${storySavedDate}</span>` : ''}
                  </div>
                  <div class="story-card-body">${escapeHTML(selectedPractice.aiStory)}</div>
                  <div class="story-card-actions">
                    <button id="edit-story" class="button secondary">Edit Story</button>
                    <button id="regenerate-story-prompt" class="button ghost">Regenerate Prompt</button>
                  </div>
                </section>
              ` : `
                ${!shouldShowPrompt ? `<button id="generate-story-prompt" class="button full-width">Generate AI Prompt</button>` : ''}
              `}
              ${shouldShowPrompt ? `
                <section class="prompt-section">
                  <div class="prompt-header">
                    <h3>AI Story Prompt</h3>
                    <p class="prompt-instructions">Copy and paste this into Claude.ai, ChatGPT, or any AI assistant.</p>
                  </div>
                  <pre id="story-prompt" class="prompt-text${isPromptExpanded ? ' expanded' : ''}">${escapeHTML(promptDisplayText)}</pre>
                  <div class="prompt-actions">
                    <button id="copy-story-prompt" class="button secondary">${promptCopyState === 'success' ? 'Copied!' : 'Copy to Clipboard'}</button>
                    ${selectedPracticeHasStory ? '' : `<button id="regenerate-story-prompt" class="button ghost">Regenerate Prompt</button>`}
                  </div>
                  ${isPromptTruncated ? `<button id="toggle-prompt-visibility" class="button ghost small" data-expanded="${isPromptExpanded ? 'true' : 'false'}">${isPromptExpanded ? 'Show less' : 'Show full prompt'}</button>` : ''}
                  ${promptCopyState === 'success' ? `<p class="copy-feedback success">Prompt copied. Paste into your favorite AI and bring the story back.</p>` : ''}
                  ${(promptCopyState === 'error' || promptCopyState === 'manual') ? `<p class="copy-feedback error">${escapeHTML(promptCopyError)}</p>` : ''}
                </section>
              ` : ''}
              ${shouldShowStoryInput ? `
                <section class="story-input">
                  <label for="ai-story-input">Paste AI-generated story here</label>
                  <textarea id="ai-story-input" class="input textarea story-textarea" rows="10" placeholder="Paste the motivational story from the AI.">${escapeHTML(storyDraft)}</textarea>
                  <div class="story-input-actions">
                    <button id="save-story" class="button" ${storyDraftTrimmed ? '' : 'disabled'}>Save Story</button>
                    <button id="cancel-story-edit" class="button ghost">Cancel</button>
                  </div>
                </section>
              ` : ''}
            </div>
          `
          : `<div class="practice-detail-empty">Select a practice to generate or edit its story.</div>`;

        const practiceCount = practices.length;
        const earnedBadges = (profile.earnedBadges || []).map(badge => ({ ...badge, id: String(badge.id) }))
          .sort((a, b) => new Date(a.earnedDate) - new Date(b.earnedDate));
        const latestBadges = earnedBadges.slice(-3).reverse();

        const milestoneBadges = ALL_BADGES
          .filter(badge => typeof badge.milestone === 'number')
          .sort((a, b) => a.milestone - b.milestone);

        const nextMilestone = milestoneBadges.find(badge => badge.milestone > practiceCount) || null;
        const previousMilestone = [...milestoneBadges]
          .reverse()
          .find(badge => badge.milestone <= practiceCount) || null;

        const startMilestoneValue = previousMilestone ? previousMilestone.milestone : 0;
        const targetMilestoneValue = nextMilestone ? nextMilestone.milestone : (previousMilestone ? previousMilestone.milestone : practiceCount || 1);
        const milestoneDenominator = Math.max(1, targetMilestoneValue - startMilestoneValue);
        const progressPercent = nextMilestone
          ? Math.min(100, Math.max(0, Math.round(((practiceCount - startMilestoneValue) / milestoneDenominator) * 100)))
          : 100;
        const sessionsRemaining = nextMilestone ? Math.max(0, targetMilestoneValue - practiceCount) : 0;
        const sessionsLabel = sessionsRemaining === 1 ? 'session' : 'sessions';
        const milestoneUnit = nextMilestone && nextMilestone.milestone === 1 ? 'practice' : 'practices';
        const nextMilestoneLabel = nextMilestone
          ? `${nextMilestone.milestone} ${milestoneUnit} Â· ${nextMilestone.name}`
          : 'Veteran status â keep sharpening your edge.';
        const totalHours = (stats.totalTime / 60).toFixed(1);
        const lastPractice = practices.length ? practices[practices.length - 1] : null;

        // Calculate identity level progress
        const identityProgress = getIdentityProgress(practiceCount);

        root.innerHTML = `
          <div class="app">
            <header class="hero">
              <div class="hero-copy">
                <p class="hero-tag">Pixel 8 ready Â· Offline Â· Dark mode only</p>
                <h1 class="title">Wrestling Journey</h1>
                <p class="hero-subtitle">Track the grind honestly. Wrestling takes years, consistency wins.</p>
              </div>
              <button class="button secondary hero-action" id="hero-log-btn">Log today</button>
            </header>

            <nav class="tabs" role="tablist">
              <button id="tab-dashboard" class="tab ${currentTab === 'dashboard' ? 'active' : ''}" role="tab">Dashboard</button>
              <button id="tab-log" class="tab ${currentTab === 'log' ? 'active' : ''}" role="tab">Log</button>
              <button id="tab-stats" class="tab ${currentTab === 'stats' ? 'active' : ''}" role="tab">Stats</button>
              <button id="tab-history" class="tab ${currentTab === 'history' ? 'active' : ''}" role="tab">History</button>
              <button id="tab-badges" class="tab ${currentTab === 'badges' ? 'active' : ''}" role="tab">Badges</button>
              <button id="tab-guide" class="tab ${currentTab === 'guide' ? 'active' : ''}" role="tab">Guide</button>
              <button id="tab-settings" class="tab ${currentTab === 'settings' ? 'active' : ''}" role="tab">Settings</button>
            </nav>

            <main class="panels">
              <!-- Dashboard - Clean & Focused -->
              <section id="section-dashboard" class="section ${currentTab === 'dashboard' ? 'active' : ''}">
                
                <!-- Panel 1: Identity Level -->
                <article class="panel level-card">
                  <div class="level-header">
                    <div class="level-title">
                      <span class="level-number">Level ${IDENTITY_LEVELS.indexOf(identityProgress.currentLevel) + 1}</span>
                      <span class="level-separator">Â·</span>
                      <span class="level-name">${identityProgress.currentLevel.name}</span>
                    </div>
                    <p class="level-quote">"${identityProgress.narrative}"</p>
                  </div>

                  <div class="level-progress-section">
                    <div class="progress-bar-container">
                      <div class="progress-bar-fill" style="width: ${identityProgress.progressPercent}%; background: ${identityProgress.currentLevel.color};"></div>
                    </div>
                    <div class="progress-info">
                      <span class="progress-percent">${identityProgress.progressPercent}% Complete</span>
                      ${identityProgress.nextLevel ? `
                        <span class="progress-next">Next: ${identityProgress.nextLevel.name} at ${identityProgress.nextLevel.threshold} practices</span>
                      ` : `
                        <span class="progress-next">Maximum level achieved!</span>
                      `}
                    </div>
                  </div>

                  <div class="stats-grid-compact">
                    <div class="stat-compact">
                      <span class="stat-label-compact">Practices</span>
                      <span class="stat-value-compact">${stats.totalPractices}</span>
                    </div>
                    <div class="stat-compact">
                      <span class="stat-label-compact">Hours</span>
                      <span class="stat-value-compact">${totalHours}</span>
                    </div>
                    <div class="stat-compact">
                      <span class="stat-label-compact">Streak</span>
                      <span class="stat-value-compact">${fullStats.streaks.current} ${fullStats.streaks.current > 0 ? 'ð¥' : 'âï¸'}</span>
                    </div>
                    <div class="stat-compact">
                      <span class="stat-label-compact">Best</span>
                      <span class="stat-value-compact">${fullStats.streaks.longest} days</span>
                    </div>
                  </div>
                </article>

                <!-- Panel 2: Current Phase & Actions -->
                <article class="panel phase-card">
                  <div class="panel-header">
                    <div>
                      <p class="eyebrow">Current Phase</p>
                      <h2>${currentPhase.name}</h2>
                    </div>
                  </div>
                  
                  <div class="milestone-progress">
                    <p class="milestone-label">Next milestone: ${nextMilestoneLabel}</p>
                    <div class="progress-bar-outer">
                      <div class="progress-bar-inner" style="width: ${progressPercent}%;"></div>
                    </div>
                    <p class="milestone-detail">${nextMilestone ? `${sessionsRemaining} more ${sessionsLabel} until ${nextMilestone.name}` : 'You carved out your own pace. Keep the story going.'}</p>
                  </div>

                  <div class="last-practice">
                    <p class="last-practice-label">Last practice</p>
                    <p class="last-practice-detail">${lastPractice ? `${new Date(lastPractice.date).toLocaleDateString()} Â· ${lastPractice.type} Â· ${lastPractice.duration} min` : 'No practices logged yet. Start today.'}</p>
                  </div>

                  <div class="dashboard-actions">
                    <button class="button" data-switch-to="log">Add practice</button>
                    <button class="button ghost" data-switch-to="history">View history</button>
                  </div>
                </article>

              </section>

              <!-- Stats (Moved from Dashboard) -->
              <section id="section-stats" class="section ${currentTab === 'stats' ? 'active' : ''}">
                <article class="panel">
                  <div class="panel-header">
                    <h2>Detailed Statistics</h2>
                    <p class="panel-subtitle">Your wrestling data breakdown.</p>
                  </div>
                  <div class="stats-grid">
                    <div class="stat-card">
                      <p class="stat-label">Total Practices</p>
                      <p class="stat-value">${stats.totalPractices}</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Hours Logged</p>
                      <p class="stat-value">${isNaN(totalHours) ? '0.0' : totalHours}</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Current Streak</p>
                      <p class="stat-value">${fullStats.streaks.current} days</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Longest Streak</p>
                      <p class="stat-value">${fullStats.streaks.longest} days</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Avg Intensity</p>
                      <p class="stat-value">${stats.avgIntensity}</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Journey Started</p>
                      <p class="stat-value">${profile.startDate ? new Date(profile.startDate).toLocaleDateString() : 'Today'}</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Last 7 Days</p>
                      <p class="stat-value">${fullStats.last7Days} practices</p>
                    </div>
                    <div class="stat-card">
                      <p class="stat-label">Last 30 Days</p>
                      <p class="stat-value">${fullStats.last30Days} practices</p>
                    </div>
                  </div>
                </article>
              </section>

              <!-- Log Practice -->
              <section id="section-log" class="section ${currentTab === 'log' ? 'active' : ''}">
                <article class="panel">
                  <div class="panel-header">
                    <div>
                      <h2>Log today\'s work</h2>
                      <p class="panel-subtitle">It should take under a minute. Be honestâprogress is earned slowly.</p>
                    </div>
                  </div>
                  <form id="practice-form" class="form-grid">
                    <div class="form-card">
                      <h3>Session basics</h3>
                      <div class="field">
                        <label for="practice-date">Date</label>
                        <input id="practice-date" type="date" class="input" value="${new Date().toISOString().split('T')[0]}">
                      </div>
                      <div class="field">
                        <label for="practice-type">Session type</label>
                        <select id="practice-type" class="input">
                          <option value="mixed">Mixed work</option>
                          <option value="technique">Technique focus</option>
                          <option value="live">Live wrestling</option>
                          <option value="conditioning">Conditioning</option>
                          <option value="competition">Competition</option>
                          <option value="open-mat">Open mat</option>
                        </select>
                      </div>
                      <div class="field">
                        <span class="label">Duration presets</span>
                        <div class="chip-row">
                          <button type="button" class="chip" data-duration="60">60 min</button>
                          <button type="button" class="chip" data-duration="90">90 min</button>
                          <button type="button" class="chip" data-duration="120">120 min</button>
                        </div>
                      </div>
                      <div class="field">
                        <label for="practice-duration">Manual duration (minutes)</label>
                        <input id="practice-duration" type="number" min="1" inputmode="numeric" class="input" placeholder="75">
                      </div>
                    </div>

                    <div class="form-card">
                      <h3>How did it feel?</h3>
                      <div class="field field-slider">
                        <label for="practice-intensity">Intensity</label>
                        <div class="slider-wrap">
                          <input id="practice-intensity" type="range" min="1" max="10" value="5" class="input range">
                          <span id="intensity-value" class="slider-value">5</span>
                        </div>
                      </div>
                      <div class="field field-slider">
                        <label for="practice-physical">Physical feel</label>
                        <div class="slider-wrap">
                          <input id="practice-physical" type="range" min="1" max="10" value="5" class="input range">
                          <span id="physical-value" class="slider-value">5</span>
                        </div>
                      </div>
                      <div class="field field-slider">
                        <label for="practice-mental">Mental feel</label>
                        <div class="slider-wrap">
                          <input id="practice-mental" type="range" min="1" max="10" value="5" class="input range">
                          <span id="mental-value" class="slider-value">5</span>
                        </div>
                      </div>
                    </div>

                    <div class="form-card">
                      <h3>Notes for future you</h3>
                      <div class="field">
                        <label for="practice-notes">Key takeaways</label>
                        <textarea id="practice-notes" class="input textarea" rows="4" placeholder="What clicked? What felt off? Be specific so future sessions improve."></textarea>
                      </div>
                    </div>

                    <div class="form-actions">
                      <button type="submit" class="button">Save practice</button>
                      <button type="button" class="button ghost" data-switch-to="dashboard">Cancel</button>
                    </div>
                  </form>
                </article>
              </section>

              <!-- History -->
              <section id="section-history" class="section ${currentTab === 'history' ? 'active' : ''}">
                <article class="panel">
                  <div class="panel-header">
                    <div>
                      <h2>Practice history</h2>
                      <p class="panel-subtitle">Scroll through the work. No shortcuts, just honest reps.</p>
                    </div>
                    <span class="phase-chip subtle">${practices.length} logged</span>
                  </div>
                  ${practices.length ? `
                    <div class="practice-history-layout">
                      <div class="practice-history-list">
                        <ul id="practice-list" class="practice-list">
                          ${practices.slice().reverse().map(p => {
                            const hasStory = Boolean(p.aiStory && p.aiStory.trim().length);
                            const isSelected = selectedPracticeId === p.id;
                            return `
                              <li class="practice-card ${isSelected ? 'selected' : ''}" data-id="${p.id}">
                                <div class="practice-card-header">
                                  <span class="practice-type">${p.type}</span>
                                  <div class="practice-card-meta">
                                    ${hasStory ? '<span class="story-indicator" title="Story saved" aria-label="Story saved">â¨</span>' : ''}
                                    <time class="practice-date">${new Date(p.date).toLocaleDateString()}</time>
                                  </div>
                                </div>
                                ${(() => {
                                  const preview = getPreviewText(p.notes);
                                  return preview ? `<p class="practice-notes">${escapeHTML(preview)}</p>` : '';
                                })()}
                                <div class="practice-metrics">
                                  ${p.duration ? `<span>${p.duration} min</span>` : ''}
                                  ${p.intensity ? `<span>Intensity ${p.intensity}/10</span>` : ''}
                                  ${typeof p.physical === 'number' ? `<span>Physical ${p.physical}/10</span>` : ''}
                                  ${typeof p.mental === 'number' ? `<span>Mental ${p.mental}/10</span>` : ''}
                                </div>
                                <button class="delete-btn" data-id="${p.id}">Delete</button>
                              </li>
                            `;
                          }).join('')}
                        </ul>
                      </div>
                      <div class="practice-detail-panel ${selectedPractice ? 'active' : ''}">
                        ${practiceDetailMarkup}
                      </div>
                    </div>
                  ` : '<div class="empty">No sessions logged yet. Start with today\'s practice.</div>'}
                </article>
              </section>

              <!-- Badges (Earned Only) -->
              <section id="section-badges" class="section ${currentTab === 'badges' ? 'active' : ''}">
                <article class="panel badge-panel">
                  <div class="panel-header">
                    <h2>Your Badges</h2>
                    <p class="panel-subtitle">Badges appear only when earned. No previews, no teasing.</p>
                  </div>
                  <div class="badge-list">
                    ${earnedBadges.length ? earnedBadges.map(badge => {
                      const badgeInfo = ALL_BADGES.find(item => item.id === badge.id);
                      return `
                        <div class="badge-item">
                          <span class="badge-emoji">${badgeInfo ? badgeInfo.icon : 'ð¥'}</span>
                          <div class="badge-info">
                            <span class="badge-name">${badgeInfo ? badgeInfo.name : 'Badge'}</span>
                            ${badgeInfo && badgeInfo.description ? `<span class="badge-detail">${badgeInfo.description}</span>` : ''}
                          </div>
                        </div>
                      `;
                    }).join('') : `
                      <div class="empty-badges">
                        <p class="empty-message">ð Your first badge awaits.</p>
                        <p class="empty-hint">Keep logging practices. Badges appear when you earn them.</p>
                      </div>
                    `}
                  </div>
                  ${earnedBadges.length > 0 ? `
                    <p class="badge-footer">More badges earned as you continue your journey.</p>
                  ` : ''}
                </article>
              </section>

              <!-- Journey Guide (Pure Inspiration) -->
              <section id="section-guide" class="section ${currentTab === 'guide' ? 'active' : ''}">
                <article class="panel journey-panel">
                  <div class="panel-header">
                    <h2>The Wrestling Journey</h2>
                    <p class="panel-subtitle">No numbers. No metrics. Just the character of each phase.</p>
                  </div>
                  <div class="journey-phases">
                    <div class="journey-phase">
                      <h3 class="phase-name">THE AMATEUR</h3>
                      <p class="phase-story">
                        This is where everyone starts. You're awkward. You're slow. You don't know what you're doing. 
                        But you're showing up. That's what matters. The discomfort is building something real.
                      </p>
                    </div>
                    
                    <div class="journey-phase">
                      <h3 class="phase-name">THE GRINDER</h3>
                      <p class="phase-story">
                        You're not dying anymore. Technique starts to click. You have moves that sometimes work. 
                        This is the foundation phase. You're building habits that will carry you through everything.
                      </p>
                    </div>
                    
                    <div class="journey-phase">
                      <h3 class="phase-name">THE TECHNICIAN</h3>
                      <p class="phase-story">
                        Now it gets fun. You're competitive. Chain wrestling flows. You're thinking ahead. 
                        You understand setups, counters, transitions. You're a real wrestler now.
                      </p>
                    </div>
                    
                    <div class="journey-phase">
                      <h3 class="phase-name">THE COMPETITOR</h3>
                      <p class="phase-story">
                        Competition is where you test yourself. Win or lose, you show up. You push through fear. 
                        The mat is your arena. This phase defines your character more than your record.
                      </p>
                    </div>
                    
                    <div class="journey-phase">
                      <h3 class="phase-name">THE VETERAN</h3>
                      <p class="phase-story">
                        You've put in years. You've survived injuries, losses, doubts. You're not chasing glory anymoreâyou're 
                        refining mastery. The young wrestlers watch how you move. Your presence teaches.
                      </p>
                    </div>
                  </div>
                </article>
              </section>

              <!-- Original Journey Guide -->
              <section id="section-guide-old" class="section" style="display: none;">
                <article class="panel">
                  <div class="panel-header">
                    <h2>Journey guide</h2>
                    <p class="panel-subtitle">Phases explain what to expect. No promises, just direction.</p>
                  </div>
                  <div class="guide-grid">
                    ${PHASES.map(phase => `
                      <div class="guide-card">
                        <p class="eyebrow">Phase ${phase.id}</p>
                        <h3>${phase.name}</h3>
                        <p class="guide-goal">Goal: ${phase.goal} logged practices</p>
                        <p class="guide-description">${phase.description}</p>
                      </div>
                    `).join('')}
                  </div>
                </article>
              </section>

              <!-- Settings -->
              <section id="section-settings" class="section ${currentTab === 'settings' ? 'active' : ''}">
                <article class="panel">
                  <div class="panel-header">
                    <h2>Data & settings</h2>
                    <p class="panel-subtitle">Your data stays on-device. Export for backups, clear when needed.</p>
                  </div>
                  ${backupSectionMarkup}
                  ${versionMarkup}
                  <div class="settings-actions">
                    <button id="export-btn" class="button secondary">Export JSON</button>
                    <button id="clear-btn" class="button danger">Clear all data</button>
                  </div>
                  <div class="settings-import">
                    <label for="import-file">Import saved data</label>
                    <input type="file" id="import-file" accept="application/json" class="input">
                    <button id="import-btn" class="button ghost">Import JSON</button>
                  </div>
                  <p class="settings-note">Clearing data removes every practice and badge. There are no take-backs.</p>
                </article>
              </section>
            </main>
          </div>
        `;

        // --- Event Listeners ---
        document.getElementById('practice-form').addEventListener('submit', handleAddPractice);
        document.getElementById('practice-intensity').addEventListener('input', () => updateSliderValue('intensity'));
        document.getElementById('practice-physical').addEventListener('input', () => updateSliderValue('physical'));
        document.getElementById('practice-mental').addEventListener('input', () => updateSliderValue('mental'));
        document.querySelectorAll('.tab').forEach(btn => btn.addEventListener('click', switchTab));
        document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', handleDeletePractice));
        document.querySelectorAll('.chip').forEach(btn => btn.addEventListener('click', handleDurationPreset));
        document.querySelectorAll('[data-switch-to]').forEach(btn => btn.addEventListener('click', quickSwitch));
        const practiceListElement = document.getElementById('practice-list');
        if (practiceListElement) {
          practiceListElement.addEventListener('click', handlePracticeListClick);
        }
        const closeDetailBtn = document.getElementById('close-practice-detail');
        if (closeDetailBtn) {
          closeDetailBtn.addEventListener('click', () => {
            selectedPracticeId = null;
            showPromptForPractice = false;
            promptCopyState = 'idle';
            promptCopyError = '';
            storyDraft = '';
            editingStory = false;
            expandedPromptPracticeId = null;
            render();
          });
        }
        const generatePromptBtn = document.getElementById('generate-story-prompt');
        if (generatePromptBtn) {
          generatePromptBtn.addEventListener('click', handleGenerateStoryPrompt);
        }
        const regeneratePromptBtn = document.getElementById('regenerate-story-prompt');
        if (regeneratePromptBtn) {
          regeneratePromptBtn.addEventListener('click', handleRegenerateStoryPrompt);
        }
        const copyPromptBtn = document.getElementById('copy-story-prompt');
        if (copyPromptBtn) {
          copyPromptBtn.addEventListener('click', handleCopyStoryPrompt);
        }
        const togglePromptBtn = document.getElementById('toggle-prompt-visibility');
        if (togglePromptBtn) {
          togglePromptBtn.addEventListener('click', handleTogglePromptVisibility);
        }
        const editStoryBtn = document.getElementById('edit-story');
        if (editStoryBtn) {
          editStoryBtn.addEventListener('click', handleEditStory);
        }
        const cancelStoryBtn = document.getElementById('cancel-story-edit');
        if (cancelStoryBtn) {
          cancelStoryBtn.addEventListener('click', handleCancelStoryEdit);
        }
        const saveStoryBtn = document.getElementById('save-story');
        if (saveStoryBtn) {
          saveStoryBtn.addEventListener('click', handleSaveStory);
        }
        const storyTextarea = document.getElementById('ai-story-input');
        if (storyTextarea) {
          storyTextarea.value = storyDraft;
          storyTextarea.addEventListener('input', handleStoryDraftInput);
          const saveButton = document.getElementById('save-story');
          if (saveButton) {
            saveButton.disabled = !storyDraft.trim();
          }
        }
        const heroButton = document.getElementById('hero-log-btn');
        if (heroButton) {
          heroButton.addEventListener('click', () => {
            currentTab = 'log';
            render();
          });
        }

        // Settings Listeners
        document.getElementById('export-btn').addEventListener('click', handleExportData);
        document.getElementById('clear-btn').addEventListener('click', handleClearData);
        document.getElementById('import-btn').addEventListener('click', handleImportData);
        const autoBackupToggle = document.getElementById('auto-backup-toggle');
        if (autoBackupToggle) {
          autoBackupToggle.addEventListener('change', handleToggleAutoBackup);
        }
        const backupDownloadBtn = document.getElementById('settings-backup-download-btn');
        if (backupDownloadBtn) {
          backupDownloadBtn.addEventListener('click', handleManualBackup);
        }
        document.querySelectorAll('[data-restore-backup-key]').forEach(button => {
          button.addEventListener('click', handleRestoreBackup);
        });

        // Initial slider values
        updateSliderValue('intensity');
        updateSliderValue('physical');
        updateSliderValue('mental');
      }
      
      // Backup helpers
      function renderBackupSettingsSection() {
        const settings = profile?.backupSettings ? normalizeBackupSettings(profile.backupSettings) : { ...DEFAULT_BACKUP_SETTINGS };
        const status = typeof AutoBackup !== 'undefined'
          ? AutoBackup.getStatus()
          : { supported: false, enabled: false, metadata: {}, availableBackups: [], statusText: 'Automatic backups are unavailable.' };
        const toggleDisabled = status.supported ? '' : 'disabled';
        const toggleChecked = settings.enabled ? 'checked' : '';
        const detailsMarkup = renderAutoBackupDetails(status);
        const restoreMarkup = renderRestoreButtons(status);
        return `
          <section class="settings-backup">
            <div class="settings-backup-header">
              <h3>Automatic backups</h3>
              <p>Rolling snapshots live safely in IndexedDB, surviving updates, reinstalls, and cache clears.</p>
            </div>
            <div class="backup-status">
              <label class="settings-toggle">
                <input type="checkbox" id="auto-backup-toggle" ${toggleChecked} ${toggleDisabled}>
                <span class="toggle-slider"></span>
                <span class="toggle-label">Automatic Backups</span>
              </label>
              <p class="settings-helper-text" id="auto-backup-status">${escapeHTML(status.statusText || '')}</p>
              ${detailsMarkup}
            </div>
            <div class="backup-actions">
              <button id="settings-backup-download-btn" class="button secondary"${status.supported ? '' : ' disabled'}>Download backup</button>
            </div>
            ${restoreMarkup}
          </section>
        `;
      }

      function renderAutoBackupDetails(status) {
        if (!status.supported) {
          return '<p class="backup-error">Automatic backups are unavailable in this browser.</p>';
        }
        const lines = [];
        const metadata = status.metadata || {};
        if (metadata.currentBackupDate) {
          const currentDate = new Date(metadata.currentBackupDate);
          lines.push(`<p>Current backup: ${formatRelativeTime(currentDate)} (${escapeHTML(currentDate.toLocaleString())})</p>`);
        } else {
          lines.push('<p>No automatic backups yet. The app will create one after the next change.</p>');
        }
        if (metadata.previousBackupDate) {
          const previousDate = new Date(metadata.previousBackupDate);
          lines.push(`<p>Previous: ${formatRelativeTime(previousDate)} (${escapeHTML(previousDate.toLocaleString())})</p>`);
        }
        if (metadata.oldestBackupDate) {
          const oldestDate = new Date(metadata.oldestBackupDate);
          lines.push(`<p>Oldest retained: ${formatRelativeTime(oldestDate)} (${escapeHTML(oldestDate.toLocaleString())})</p>`);
        }
        if (metadata.lastManualDownloadISO) {
          const manualDate = new Date(metadata.lastManualDownloadISO);
          lines.push(`<p>Manual download: ${formatRelativeTime(manualDate)} (${escapeHTML(manualDate.toLocaleString())})</p>`);
        }
        if (metadata.lastRestoreISO && metadata.lastRestoreKey) {
          const restoreDate = new Date(metadata.lastRestoreISO);
          lines.push(`<p>Last restore: ${escapeHTML(metadata.lastRestoreKey)} version ${formatRelativeTime(restoreDate)} (${escapeHTML(restoreDate.toLocaleString())})</p>`);
        }
        return lines.join('');
      }

      function renderRestoreButtons(status) {
        if (!status.supported) {
          return '';
        }
        if (!Array.isArray(status.availableBackups) || status.availableBackups.length === 0) {
          return '<div class="backup-versions"><p>No stored versions yet.</p></div>';
        }
        const buttons = status.availableBackups.map(entry => {
          const label = entry.key === 'current'
            ? 'Current backup'
            : entry.key === 'previous'
              ? 'Previous backup'
              : 'Oldest backup';
          const when = entry.timestamp ? new Date(entry.timestamp) : null;
          const detail = when ? `${formatRelativeTime(when)} (${escapeHTML(when.toLocaleString())})` : 'Timestamp unavailable';
          const sizeText = entry.size ? ` â¢ ${formatBytes(entry.size)}` : '';
          return `
            <button class="button ghost" data-restore-backup-key="${entry.key}">
              <span>${escapeHTML(label)}</span>
              <small>${escapeHTML(detail)}${sizeText ? escapeHTML(sizeText) : ''}</small>
            </button>
          `;
        }).join('');
        return `
          <div class="backup-versions">
            <h4>Restore a version</h4>
            <div class="backup-version-buttons">
              ${buttons}
            </div>
          </div>
        `;
      }

      function renderAppVersionMarkup() {
        const displayVersion = appVersion || 'â';
        return `
          <div class="settings-version">
            <div class="settings-version-label">App version</div>
            <div class="settings-version-value" id="app-version">${escapeHTML(displayVersion)}</div>
          </div>
        `;
      }

      function isAutoBackupAvailable() {
        return typeof AutoBackup !== 'undefined' && AutoBackup.supported;
      }

      function isBackupEnabled() {
        const settings = profile?.backupSettings ? normalizeBackupSettings(profile.backupSettings) : null;
        return Boolean(settings?.enabled && isAutoBackupAvailable());
      }

      function formatBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) {
          return '';
        }
        const units = ['bytes', 'KB', 'MB', 'GB'];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
          value /= 1024;
          unitIndex += 1;
        }
        return `${value.toFixed(unitIndex === 0 ? 0 : 1)} ${units[unitIndex]}`;
      }

      function formatRelativeTime(date) {
        try {
          const now = new Date();
          const diffMs = now.getTime() - date.getTime();
          if (!Number.isFinite(diffMs)) {
            return date.toLocaleString();
          }
          const diffMinutes = Math.round(diffMs / (1000 * 60));
          if (diffMinutes < 1) return 'just now';
          if (diffMinutes < 60) return `${diffMinutes} min ago`;
          const diffHours = Math.round(diffMinutes / 60);
          if (diffHours < 24) return `${diffHours} hr${diffHours === 1 ? '' : 's'} ago`;
          const diffDays = Math.round(diffHours / 24);
          if (diffDays < 7) return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
          const diffWeeks = Math.round(diffDays / 7);
          if (diffWeeks < 5) return `${diffWeeks} week${diffWeeks === 1 ? '' : 's'} ago`;
          return date.toLocaleDateString();
        } catch (error) {
          return date.toLocaleString();
        }
      }

      async function handleManualBackup() {
        if (!isAutoBackupAvailable()) {
          alert('Automatic backups are unavailable in this browser.');
          return;
        }
        try {
          await AutoBackup.manualBackup();
          await updateBackupSettings({ lastManualDownload: new Date().toISOString() }, { silent: true });
        } catch (error) {
          console.error('Manual backup failed', error);
          alert(error?.message || 'Could not create the backup download.');
        }
        render();
      }

      async function handleRestoreBackup(event) {
        const key = event?.currentTarget?.dataset?.restoreBackupKey;
        if (!key) {
          return;
        }
        if (!isAutoBackupAvailable()) {
          alert('Automatic backups are unavailable in this browser.');
          return;
        }
        if (!confirm('Restore this backup? This will replace your current data.')) {
          return;
        }
        try {
          await AutoBackup.restoreFromBackup(key);
          practices = await getPractices();
          profile = await getProfile();
          render();
          scheduleAutoBackup('restored', { immediate: true });
        } catch (error) {
          console.error('Restore failed', error);
          alert(error?.message || 'Could not restore from the selected backup.');
        }
      }

      function handleToggleAutoBackup(event) {
        const enabled = Boolean(event?.target?.checked);
        updateBackupSettings({ enabled });
        if (isAutoBackupAvailable()) {
          AutoBackup.setEnabled(enabled);
        }
      }

      function scheduleAutoBackup(reason, { immediate = false, userInitiated = false } = {}) {
        if (!isBackupEnabled() || !isAutoBackupAvailable()) {
          return;
        }
        AutoBackup.handleStoreSave({ reason, immediate, userInitiated });
      }

      async function buildBackupPayload(reason) {
        const snapshot = await exportAllData();
        const nowIso = new Date().toISOString();
        const practices = Array.isArray(snapshot.practices)
          ? snapshot.practices.slice(-BACKUP_SNAPSHOT_ENTRY_LIMIT)
          : [];
        const totalPractices = Array.isArray(snapshot.practices) ? snapshot.practices.length : 0;
        return {
          ...snapshot,
          practices,
          backup: {
            generatedAt: nowIso,
            reason,
            version: BACKUP_METADATA_VERSION,
            totalPractices,
            includedPractices: practices.length,
            appVersion: appVersion || null
          }
        };
      }

      async function updateBackupSettings(updates, { silent = false } = {}) {
        const current = profile?.backupSettings ? normalizeBackupSettings(profile.backupSettings) : { ...DEFAULT_BACKUP_SETTINGS };
        const merged = {
          ...current,
          ...updates
        };
        const hasChanges = Object.keys(merged).some(key => current[key] !== merged[key]);
        if (!hasChanges) {
          if (!silent) {
            render();
          }
          return;
        }
        profile = {
          ...profile,
          backupSettings: merged
        };
        await setProfile(profile);
        if (!silent) {
          render();
        }
      }

      // --- HANDLERS ---
      function updateSliderValue(name) {
        document.getElementById(`${name}-value`).textContent = document.getElementById(`practice-${name}`).value;
      }
      
      function handleDurationPreset(e) {
          document.getElementById('practice-duration').value = e.target.dataset.duration;
      }

      function quickSwitch(e) {
        const target = e.currentTarget.getAttribute('data-switch-to');
        if (target) {
          currentTab = target;
          render();
        }
      }

      async function handleAddPractice(e) {
        e.preventDefault();
        const notes = document.getElementById('practice-notes').value.trim();
        const duration = parseInt(document.getElementById('practice-duration').value) || 0;
        const type = document.getElementById('practice-type').value;
        const intensity = parseInt(document.getElementById('practice-intensity').value);
        const physical = parseInt(document.getElementById('practice-physical').value);
        const mental = parseInt(document.getElementById('practice-mental').value);
        const date = document.getElementById('practice-date').value;
        
        if (!notes || duration <= 0) {
            alert("Please provide notes and a valid duration.");
            return;
        }

        const newPractice = {
            id: Date.now(),
            notes,
            duration,
            type,
            intensity,
            physical,
            mental,
            date,
            practiceNumber: practices.length + 1,
            aiStory: null,
            storyGeneratedDate: null
        };

        await dbAddPractice(newPractice);
        scheduleAutoBackup('practice-added');

        // Clear the form
        document.getElementById('practice-form').reset();
        document.getElementById('practice-date').value = new Date().toISOString().split('T')[0];
        document.getElementById('practice-intensity').value = 5;
        document.getElementById('practice-physical').value = 5;
        document.getElementById('practice-mental').value = 5;

        // Switch to Dashboard and re-render
        currentTab = 'dashboard';
        render();
      }

      function switchTab(e) {
        currentTab = e.target.id.split('-')[1];
        render();
      }

      async function handleDeletePractice(e) {
        e.stopPropagation();
        const id = parseInt(e.target.dataset.id);

        if (confirm("Are you sure you want to delete this practice log?")) {
            await dbDeletePractice(id);
            scheduleAutoBackup('practice-deleted');
            if (selectedPracticeId === id) {
                selectedPracticeId = null;
                showPromptForPractice = false;
                promptCopyState = 'idle';
                promptCopyError = '';
                storyDraft = '';
                editingStory = false;
                expandedPromptPracticeId = null;
            }
            // Re-render to update history and stats
            render();
        }
      }
      
      async function handleExportData() {
        try {
          const snapshot = await exportAllData();
          const dataStr = JSON.stringify(snapshot, null, 2);
          const blob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `wrestling_journey_export_${new Date().toISOString().split('T')[0]}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Error exporting data', error);
          alert('Could not export your data. Please try again.');
        }
      }

      async function handleClearData() {
          document.getElementById('confirm-modal').style.display = 'block';
      }

      // Modal event listeners
      document.getElementById('confirm-cancel').addEventListener('click', () => {
          document.getElementById('confirm-modal').style.display = 'none';
      });

      document.getElementById('confirm-clear').addEventListener('click', async () => {
          document.getElementById('confirm-modal').style.display = 'none';
          await clearAllData();
          profile = await getProfile();
          scheduleAutoBackup('cleared-data', { immediate: true });
          currentTab = 'dashboard';
          alert("All data cleared!");
          render();
      });

      function handleImportData() {
          const fileInput = document.getElementById('import-file');
          const file = fileInput.files[0];
          if (!file) {
              alert("Please select a JSON file to import.");
              return;
          }

          const reader = new FileReader();
          reader.onload = async (e) => {
              try {
                  const importedData = JSON.parse(e.target.result);
                  if (importedData.practices && importedData.profile) {
                      // Simple implementation: delete all current and insert imported
                      await clearAllData();
                      
                      for (const p of importedData.practices) {
                          await dbAddPractice(p);
                      }
                      await setProfile(importedData.profile);
                      profile = await getProfile();
                      scheduleAutoBackup('imported-data', { immediate: true, userInitiated: true });

                      currentTab = 'dashboard';
                      alert("Data imported successfully! Rendering...");
                      render();
                  } else {
                      alert("Invalid file format. Must contain 'practices' and 'profile' arrays/objects.");
                  }
              } catch (error) {
                  alert("Error parsing JSON file: " + error.message);
              }
          };
          reader.readAsText(file);
      }

      function handlePracticeListClick(e) {
        if (e.target.closest('.delete-btn')) {
          return;
        }
        const card = e.target.closest('.practice-card');
        if (!card) return;
        const id = parseInt(card.dataset.id);
        if (Number.isNaN(id)) return;
        if (selectedPracticeId === id) {
          return;
        }
        selectedPracticeId = id;
        showPromptForPractice = false;
        promptCopyState = 'idle';
        promptCopyError = '';
        storyDraft = '';
        editingStory = false;
        expandedPromptPracticeId = null;
        render();
      }

      function getSelectedPractice() {
        return practices.find(p => p.id === selectedPracticeId) || null;
      }

      function handleGenerateStoryPrompt() {
        if (!getSelectedPractice()) return;
        showPromptForPractice = true;
        promptCopyState = 'idle';
        promptCopyError = '';
        storyDraft = '';
        editingStory = false;
        expandedPromptPracticeId = null;
        render();
      }

      function handleRegenerateStoryPrompt() {
        if (!getSelectedPractice()) return;
        showPromptForPractice = true;
        promptCopyState = 'idle';
        promptCopyError = '';
        storyDraft = '';
        editingStory = false;
        expandedPromptPracticeId = null;
        render();
      }

      async function handleCopyStoryPrompt() {
        if (!currentPromptText) {
          promptCopyState = 'error';
          promptCopyError = 'Prompt not ready. Regenerate and try again.';
          render();
          return;
        }
        try {
          if (!navigator.clipboard) {
            throw new Error('Clipboard access is unavailable.');
          }
          await navigator.clipboard.writeText(currentPromptText);
          promptCopyState = 'success';
          promptCopyError = '';
        } catch (error) {
          console.error('Copy failed', error);
          promptCopyState = 'manual';
          promptCopyError = 'Could not copy automatically. Select the text above and copy it manually.';
        }
        render();
      }

      function handleEditStory() {
        const practice = getSelectedPractice();
        if (!practice) return;
        editingStory = true;
        showPromptForPractice = false;
        promptCopyState = 'idle';
        promptCopyError = '';
        storyDraft = practice.aiStory || '';
        expandedPromptPracticeId = null;
        render();
      }

      function handleCancelStoryEdit() {
        editingStory = false;
        storyDraft = '';
        if (!getSelectedPractice()?.aiStory) {
          showPromptForPractice = false;
        }
        promptCopyState = 'idle';
        promptCopyError = '';
        expandedPromptPracticeId = null;
        render();
      }

      function handleStoryDraftInput(e) {
        storyDraft = e.target.value;
        const saveButton = document.getElementById('save-story');
        if (saveButton) {
          saveButton.disabled = !storyDraft.trim();
        }
      }

      function handleTogglePromptVisibility() {
        if (!selectedPracticeId) {
          return;
        }
        if (expandedPromptPracticeId === selectedPracticeId) {
          expandedPromptPracticeId = null;
        } else {
          expandedPromptPracticeId = selectedPracticeId;
        }
        render();
      }

      async function handleSaveStory() {
        const practice = getSelectedPractice();
        if (!practice) return;
        const draft = storyDraft.trim();
        if (!draft) {
          alert('Paste or write your story before saving.');
          return;
        }
        const updatedPractice = {
          ...practice,
          aiStory: draft,
          storyGeneratedDate: new Date().toISOString()
        };
        try {
          await dbUpdatePractice(updatedPractice);
          scheduleAutoBackup('story-updated');
          showPromptForPractice = false;
          promptCopyState = 'idle';
          promptCopyError = '';
          storyDraft = '';
          editingStory = false;
          expandedPromptPracticeId = null;
          render();
        } catch (error) {
          console.error('Error saving story', error);
          alert('Could not save the story. Please try again.');
        }
      }

      function escapeHTML(str = '') {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function getPreviewText(text = '', maxLines = 2, maxCharacters = 160) {
        if (text === null || text === undefined) {
          return '';
        }
        const normalized = String(text).trim();
        if (!normalized) {
          return '';
        }
        const lines = normalized.split(/\r?\n/);
        let truncated = false;
        const limitedLines = lines.slice(0, maxLines);
        if (lines.length > maxLines) {
          truncated = true;
        }
        let preview = limitedLines.join('\n');
        if (preview.length > maxCharacters) {
          preview = preview.slice(0, maxCharacters).trimEnd();
          truncated = true;
        }
        if (!truncated) {
          return normalized;
        }
        return `${preview.replace(/[\s\r\n]+$/g, '')}â¦`;
      }

      function generateStoryPrompt(practice, userStats, identityLevel) {
        const totalHoursValue = Number.isFinite(userStats.totalHours) ? userStats.totalHours : 0;
        const formattedHours = totalHoursValue.toFixed(1);
        const streak = userStats.streaks && Number.isFinite(userStats.streaks.current)
          ? userStats.streaks.current
          : 0;
        const practiceNumber = practice.practiceNumber ?? userStats.practiceCount ?? '';

        return `You are a motivational wrestling journey storyteller. Generate an engaging practice story.

WRESTLER PROFILE:
- Total Practices: ${userStats.practiceCount}
- Total Hours: ${formattedHours}
- Current Level: ${identityLevel.name}
- Current Streak: ${streak} days
- Identity Phase: ${identityLevel.narrative}

TODAY'S PRACTICE:
- Date: ${practice.date}
- Duration: ${practice.duration} minutes
- Type: ${practice.type}
- Intensity: ${practice.intensity}/10
- Physical Feel: ${practice.physical}/10
- Mental Feel: ${practice.mental}/10

NOTES:
${practice.notes}

Generate a compelling, motivational story (200-300 words) about this practice session. Include:
- Acknowledgment of specific challenges (intensity, physical feel)
- Celebration of showing up and what they worked on
- Context of their journey (practice count, level, progress)
- Forward-looking motivation toward next milestone
- Use second-person ("you") narrative
- Make it inspiring but realistic
- Reference their identity level context

Format: Start with a bold title like "Practice #${practiceNumber}: [Your Title]"`;
      }

      // --- AI Prompt Generation (Needs update for TRUTH_DOC) ---
      function generatePrompt() {
        const lastPractice = practices.length > 0 ? practices.slice(-1)[0] : null;
        let basePrompt = "Generate a short, motivational prompt for a wrestler based on their training log. The tone should be coach-like, direct, and slightly challenging. Focus on the 'Reflect' section of the prompt.";
        
        if (lastPractice) {
            basePrompt += ` The last practice was on ${new Date(lastPractice.date).toLocaleDateString()}, focusing on ${lastPractice.type} with ${lastPractice.intensity}/10 intensity. Notes: "${lastPractice.notes.substring(0, 100)}..."`;
        } else {
            basePrompt += " The wrestler is just starting out, encourage them to log their first session.";
        }

        const promptTemplate = [
            "**Goal:** Define a single, measurable objective for your next session.",
            "**Drill:** Pick one technique from your notes and drill it 50 times perfectly.",
            "**Reflect:** Visualize your biggest weakness from the last session. What one thing would have changed the outcome?"
        ];

        return `
            **AI-Ready Prompt Generator (Copy Below to AI Chat)**
            ---
            ${basePrompt}
            ---
            **Template:**
            ${promptTemplate.join('\n')}
        `;
      }
      
      function handleGeneratePrompt() {
          // This function is no longer needed as the prompt is generated on render,
          // but if we were to move the Motivate section to its own screen, it would be used here.
      }

      async function loadAppVersion() {
        try {
          if (!manifestVersionPromise) {
            manifestVersionPromise = fetch('manifest.json', { cache: 'no-cache' })
              .then(response => (response.ok ? response.json() : {}))
              .catch(() => ({}));
          }
          const manifest = await manifestVersionPromise;
          const version = manifest?.version || '';
          if (version && version !== appVersion) {
            appVersion = version;
            render();
          }
        } catch (error) {
          console.warn('Unable to load app version', error);
        }
      }

      function showUpdateNotification() {
        if (document.getElementById('update-banner')) {
          return;
        }
        const banner = document.createElement('div');
        banner.id = 'update-banner';
        banner.className = 'update-banner';
        banner.innerHTML = `
          <div class="update-banner-message">
            <strong>Update available</strong>
            <p>A new version of Wrestling Journey is ready. Refresh to get the latest improvements.</p>
          </div>
          <div class="update-banner-actions">
            <button id="update-refresh-btn" class="button secondary">Refresh now</button>
            <button id="update-dismiss-btn" class="button ghost">Later</button>
          </div>
        `;
        document.body.appendChild(banner);
        document.getElementById('update-refresh-btn').addEventListener('click', reloadForUpdate);
        document.getElementById('update-dismiss-btn').addEventListener('click', dismissUpdateNotification);
        if (updateBannerTimeoutId) {
          clearTimeout(updateBannerTimeoutId);
        }
        updateBannerTimeoutId = setTimeout(() => {
          reloadForUpdate();
        }, 30000);
      }

      function dismissUpdateNotification() {
        if (updateBannerTimeoutId) {
          clearTimeout(updateBannerTimeoutId);
          updateBannerTimeoutId = null;
        }
        const banner = document.getElementById('update-banner');
        if (banner && banner.parentNode) {
          banner.parentNode.removeChild(banner);
        }
      }

      function reloadForUpdate() {
        if (updateBannerTimeoutId) {
          clearTimeout(updateBannerTimeoutId);
          updateBannerTimeoutId = null;
        }
        if (pendingUpdateWorker) {
          pendingUpdateWorker.postMessage({ type: 'SKIP_WAITING' });
        } else {
          window.location.reload();
        }
      }

      async function registerServiceWorker() {
        if (!('serviceWorker' in navigator)) {
          return;
        }
        try {
          const registration = await navigator.serviceWorker.register('./service-worker.js');
          serviceWorkerRegistration = registration;
          if (registration.waiting && navigator.serviceWorker.controller) {
            pendingUpdateWorker = registration.waiting;
            showUpdateNotification();
          }
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (!newWorker) {
              return;
            }
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                pendingUpdateWorker = newWorker;
                showUpdateNotification();
              }
            });
          });
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (hasReloadedForUpdate) {
              return;
            }
            hasReloadedForUpdate = true;
            window.location.reload();
          });
          navigator.serviceWorker.addEventListener('message', event => {
            if (event.data && event.data.type === 'SW_ACTIVATED') {
              console.log(`Service worker activated with version ${event.data.version}`);
              pendingUpdateWorker = null;
              dismissUpdateNotification();
              hasReloadedForUpdate = false;
              loadAppVersion();
            }
          });
          if ('visibilityState' in document) {
            setInterval(() => {
              if (document.visibilityState === 'visible') {
                registration.update();
              }
            }, 5 * 60 * 1000);
          }
        } catch (error) {
          console.warn('Service worker registration failed', error);
        }
      }

      loadAppVersion();
      registerServiceWorker();
      render();
    });
  </script>

  <!-- Confirmation Modal -->
  <div id="confirm-modal" class="modal" style="display: none;">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>â ï¸ Clear All Data</h3>
      </div>
      <div class="modal-body">
        <p>This action cannot be undone. You will lose:</p>
        <ul>
          <li>All practice logs and training history</li>
          <li>All earned badges and achievements</li>
          <li>All progress and streak data</li>
        </ul>
        <p><strong>Are you absolutely sure?</strong></p>
      </div>
      <div class="modal-actions">
        <button id="confirm-cancel" class="button">Cancel</button>
        <button id="confirm-clear" class="button danger">Yes, Clear Everything</button>
      </div>
    </div>
  </div>
</body>
</html>
